import std.*;

// Debug settings (0 = no debug, 1 = IRC debug, 2 = Full debug)
Int debugLevel = 0;

// Socket and sleep counter.
TcpSocket tcp("");
Int sleepCount = 0;
Bool connected = false;

// ---------------------------------------------
// Callback and IRC setup.

// Void onConnected()
Function<Void> onConnected;
Void setOnConnected(Function<Void> f) {
	onConnected = f;
}

// Void onAuthenticated()
Function<Void> onAuthenticated;
Void setOnAuthenticated(Function<Void> f) {
	onAuthenticated = f;
}

// Void onChannelMessage(String channel, String nick, String message)
Function<Void, String, String, String> onChannelMessage;
Void setOnChannelMessage(Function<Void, String, String, String> f) {
	onChannelMessage = f;
}

// Void onPrivateMessage(String nick, String message)
Function<Void, String, String> onPrivateMessage;
Void setOnPrivateMessage(Function<Void, String, String> f) {
	onPrivateMessage = f;
}

// ------------------------------------------------------------------

// 0 - before connection

Void setDebug(const Int level) {
	debugLevel = level;
}

// 1 - after connected, but not authenticated

Void setUser(const String username, const String hostname, const String servername, const String realname) {
	String strUser = "USER " + username + " " + hostname + " " + servername + " :" + realname + "\n";
	tcp.send(strUser.toByteArray());
}

Void nick(const String nick) {
	String strNick = "NICK " + nick + "\n";
	tcp.send(strNick.toByteArray());
}

// 2 - after authenticated

Void join(const String channel) {
	String strJoin = "JOIN " + channel + "\n";
	tcp.send(strJoin.toByteArray());
}


// ------------------------------------------------------------------
// Internal code.

Void debug(const Int level, const String message) {
	if (debugLevel >= level) {
		println("(" + level.toString() + ") " + message);
	}
}

Bool connect(const String host, const Int port) {
	tcp.setHost(host);
	tcp.setPort(port);
	tcp.setTimeout(500);

	tcp.connect();
	
	if (!tcp.good()) {
		println("[" + tcp.getError().toString() + "] " + tcp.getErrorMessage());
		return false;
	} else {
		return true;
	}
}

Void keepAlive() {
	String strPing = "PING " + nick + "\n";
	tcp.send(strPing.toByteArray());
}

Void process(String line) {
	if (/^:[^ ]+ NOTICE \* :[^ ]+ Looking/.matches(line)) {
		/* Looking up for your hostname... */
		debug(1, "Looking up for your hostname...");
		
		onConnected.call();
	} else if (/^:[^ ]+ 001 [^ ]+ :Welcome.*/.matches(line)) {
		/* 001 Welcome */
		debug(1, "001 Welcome.");
		connected = true;
		
		// We authenticated.
		onAuthenticated.call();
	} else if (/^:[^ ]+ PRIVMSG #[^ ]+ :.*/.matches(line)) {
		/* PRIVMSG to a channel */
		//String s = "PRIVMSG #clever-pt :[debug shit] line = \"" + line + "\"\n";
		//tcp.send(s.toByteArray());
	} else {
		debug(1, "No match: " + line);
	}
}

Void loop() {
	while (tcp.isOpen()) {
		debug(2, "tcp.isOpen() returned true.");
		if (tcp.poll()) {
			debug(2, "tcp.poll() returned true.");
			String data = "";

			// Read all data until there's nothing more to read.
			while (tcp.poll()) {
				debug(2, "tcp.poll() returned true.");
				Array<Byte> buffer = tcp.receive(1024);
				if (tcp.good()) {
					String bufferStr(buffer);
					data = data + bufferStr;
				} else {
					break;
				}
				debug(2, "Data added. Polling more data...");
			}
			debug(2, "Data polled.");
			
			// Process the data: strings are splitted by a \n.
			Array<String> lines = data.replace("\r", "").split("\n");
			for (Int i = 0; i < lines.size(); i++) {
				if (lines[i].trim() != "") {
					process(lines[i].trim());
				}				
			}
		}

		// Sleep for 1s (low the CPU usage).
		sleep(1000);
		sleepCount++;
		
		// If we already sleep for more than 60s, send keep-alive ping.
		if (connected && sleepCount >= 60) {
			debug(1, "Sending keep-alive.");
			keepAlive();
			sleepCount = 0;
		}
	}
}
